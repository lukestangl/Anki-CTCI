Is Unique: Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?	<div><b>Solution 1: With data structure</b></div><div>- Return false if exceeds total number of allowed characters</div><div>- Add all elements to a dictionary</div><div>- Before adding, check if it is already in a dictionary.</div><div>&nbsp; &nbsp; &nbsp; If yes, return false</div><div>&nbsp; &nbsp; &nbsp; At the end return true</div><b>Time/Space:</b><div>Time O(n) Space O(n)</div><div><br></div><div><b>Solution 2: With data structure</b><br></div><div>- Use a bit map to reduce the size by 8 since only need a bit for each character instead of a byte</div><div>An int only has 32 bits, so will only be able to use lowercase alphabet values</div><div><br></div><div><b>Solution 3: Without data structure&nbsp;</b></div><div>- Compare each character with all other characters using two four loops</div><div><br></div><div><b>Time/Space:</b><div>Time O(n^2) Space O(1)</div></div><div><br></div><div><div><b>Solution 4: Without data structure&nbsp;</b></div><div>- Sort the string using timsort (pythons default sort) and then linearly walk through</div><div><br></div><div><b>Time/Space:</b><div>Time O(nlogn) Space O(n)&nbsp;</div></div></div><div><br></div><div><b>Questions:</b></div><div>Is it in Ascii (128 chars), extended Ascii (256 chars), or Unicode (Alot Chinesse Russian etc)<br><div><br></div><div><br></div><div><br></div><div><br></div></div>	
Check Permutations: Given two strings, write a method to decide if one is a permutation of the other.	<div><b>Solution 1:</b>&nbsp;<b>Sorting</b></div><div>- Return if strings are not same length<br><div>- Sort (timsort) both strings and compare each value</div><div><div><b><br></b></div><div><b>Time/Space:&nbsp;</b></div></div></div><div>Time O(nlogn + mlogm)</div><div>Space O(n)&nbsp;</div><div><b><br></b></div><b>Solution 2:</b>&nbsp;<b>Using an Array</b><div>- Return if strings are not same length<br><div>- Walkthrough each character and increment an array by one</div><div>- Walkthrough and decrement for each char of second string</div><div>&nbsp; &nbsp; &nbsp; If any less than zero return False</div><div><br></div><div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n) or O(26)</div><div><b><br></b></div><div><b>Other Options:</b></div><div>Using a dictionary but will use more space unless we are working with a large character set and a smaller string size</div><div><b><br></b></div><div><b>Questions:</b></div><div>What types of characters are allowed? E.g. All lower case results only needing 26 array</div><div>Is lower and upper case considered the same value?</div></div><div>Is white space significant?</div></div>	
"URLify: Write a method to replace all space in a string with "" "". You may assume that the string has sufficient space at the end to hold the adidtional characters, and that you are given the ""true"" length of the string.<div><br></div><div>Ex: ""Mr John Smith&nbsp; &nbsp; "", 13 -&gt; ""Mr John Smith""</div>"	<b>Solution 1: Using pointers</b><div>- Strings are immutable<br><div>- Start from the back with two pointers</div><div>- Increment one until it hits something not whitespace</div><div>- Move to back and increment both pointers up one</div><div>&nbsp; &nbsp; &nbsp; If next character not whitespace repeat process</div><div>&nbsp; &nbsp; &nbsp; Else move   to end and increment up by 3 slots</div><div><b>Time/Space:</b></div><div>Time O(n)&nbsp;</div><div>Space O(1)</div></div>	
Palindrome Permutation: Given a string, write a function to check if it is a permutatioin of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is rearrangement of letters. The palindrome does not need to be limited to just dictioanry words. You can ignore casing and non-letter characters.&nbsp;	<b>Solution 1: Bitvector&nbsp;</b><div>- For it to be a permutation of a palindrome it needs even counts for each character and/or one odd count</div><div>- Add all characters to an array</div><div>- For each bit in declared number (if &lt; 32 will be int otherwise long), XOR (^) each bit with 1 that is the same value as int</div><div>&nbsp; &nbsp; &nbsp; If final number is zero return true</div><div>- Take final number substract one and AND (&amp;) it with the previous number.</div><div>&nbsp; &nbsp; &nbsp; If it is zero, return true</div><div>&nbsp; &nbsp; &nbsp; else return false</div><div><b><br></b></div><div><b>Time/Space:</b></div><div>Time: O(n)</div><div>Space: O(1)</div><div><br></div><div><b>Other Solutions:</b></div><div>Using a hash map and check number of odd numbers while we add character counts. Can be faster since don't have to walk through all afterwards</div><div><br></div><div>Using hash map and incrementing each. Later check that only one is odd.&nbsp;</div>	
One Away: There are three types of edits that can be performed on strings: insert a character, remove a character or replace a character. Given two strings, write a function to check if there are one edit (or zero edits) away.	"<b>Solution 1:</b>&nbsp;<div>- Check that the lengths are different at most by 1 (e.g. abs(len(s1) - len(s2)) &lt; 2)</div><div>- Pass into function below</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n + m)</div><div>Space O(1)</div><div><br></div><div><b>Other Solutions:</b></div><div>Break appart the functions depending on if the length ==. More code but more readable.</div><div><br></div><div>&nbsp; &nbsp; &nbsp;&nbsp;<img src=""Screen Shot 2021-08-29 at 5.07.06 PM.png""><br></div><div><br></div>"	
String Compression: Implement a method to perform basic string compression using the counts of repeated characters. Unless string would be larger than original. Assume only uppercase and lowercase letters.<div>aabcccccaaa =&gt; a2b1c5a3</div><div><br></div>	<b>Solution 1: Simple</b><div>- Create a list array<br><div>- Walk through the string and count the characters when they are the same</div></div><div>&nbsp; &nbsp; &nbsp; Each time the char changes, append the char and count and reset the count = 1</div><div>- Return minimum length string&nbsp;</div><div><b>Time/Space</b></div><div>Time O(n)</div><div>Space O(k)&nbsp;</div><div>&nbsp; &nbsp;k = unique characters</div><div><br></div><div><b>Other Solutions:</b></div><div>Check before the amount of unique characters. New array will be double that size. If size &gt; original string return original string</div><div>+ Doesn't need to double once is exceeds array bounds and can avoid creating a new string&nbsp;</div>	
Zero Matrix: Write an algorithm such that if an element in an MxN matrix is 0, it's entire row and column are set to 0.	<b>Solution 1: My Solution</b><div>- Walk through Matrix and keep track of all Columns and Rows that have a zero in them</div><div>- Walk through a second time and change all indexes that share the same row and colum to 0</div><div><b>Time/Space:</b></div><div>Time O(MN)</div><div>Space O(M + N)</div><div><br></div><div><b>Solution 2: Better Solution</b></div><div>- Walk through first row and column looking for zeros and record result</div><div>- Walk through rest of matrix and record in first column and first row whether there is a zero or not</div><div>- Create two functions that nullify rows and columns</div><div>- Walk through first row, nullify columns (avoid first) and columns, nullify rows</div><div>- Check recorded results and nullify first row and column accordingly&nbsp;<br><b>Time/Space:</b></div><div>Time O(MN)</div><div>Space O(1)</div>	
"String Rotation: Assume you have a method isSubstring which checks if one word is a substring of antoher. Given two string, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (e.g. ""waterbottle"" is a rotation of ""erbattlewat"""	<b>Solution 1:</b><div>- Add strings together and call isSubstring on the new string using the other string that wasn't doubled</div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n)</div>	
Rotate Matrix: Given an image represented by an N X N matrix, where each pixel in the image is represented by an integer, write a method to rotate the image by 90 degrees. Can you do this in place?	"<b>Solution 1:</b>&nbsp;<div>- Calculate the running distance (len - 1) and use it inc/dec the rows or columns. It will dec be 2 each time.</div><div>- All index will move inward by one</div><div>- Solution seen below</div><div><b>Time/Space:</b></div><div>Time O(NN)</div><div>Space O(1)</div><div><br></div><div><b>Solution 2:</b></div><div>Trampose and reverse the matrix</div><div><b>Time/Space</b></div><div>Time O(NN)</div><div>Space O(1)</div><div><br></div><div><div>&nbsp;<img src=""Screen Shot 2021-08-30 at 8.58.32 PM.png""></div></div><div><br></div>"	
Remove Dups: Write code to remove duplicates from an sorted linked list? Without temporary buffer?	<b>Solution 1:</b><div>- Walk through and add elements to set/check if they are in the dictionary</div><div>&nbsp; &nbsp; &nbsp; If yes, set prev.next = node.next</div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n)</div><div><br></div><div><b>Solution 2: Without temporary buffer</b></div><div>- Use two pointers. Have one start at beginning and other two walk completely through until end comparing each using while(runner.next != None)</div><div>&nbsp; &nbsp; &nbsp; If yes, set node.next = node.next.next</div><div><b>Time/Space:</b></div><div>Time O(n^2)</div><div>Space O(1)</div>	
Return Kth to Last: Implement an algorithm to find the kth to last element of a singly linked list.	"<b>Solution 1: Use two pointers</b><div>- Have the runner walk through K nodes ahead</div><div>- Have both the current and runner walk together until runner.next == None</div><div>&nbsp; &nbsp; &nbsp; Return current node</div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(1)</div><div><br></div><div><b>Solution 2: Use recursion</b></div><div>- Count from the back using recursion</div><div>- Code shown below</div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n)</div><div><br></div><div><b>Questions:</b>&nbsp;</div><div>Where does K start? 0 or 1?</div><div>Is the linked list size known?</div><div><br></div><div><img src=""Screen Shot 2021-08-31 at 7.32.21 AM.png""><br></div>"	
Delete Middel Node: Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.&nbsp;<div>E.g. a -&gt; b -&gt; c, b&nbsp; =&gt; a-&gt;c</div>	<b>Solution 1:</b><div>Take the next node and copy it's contents to current node. Set current node.next = node.nex next assuming node.next != None</div><div><b>Question:</b></div><div>The problem can't be solved if we are given last element.&nbsp;</div>	
Partition: Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x.&nbsp;<div>E.g. 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1 (partition 5) =&gt; 3-&gt;1-&gt;2&nbsp; &nbsp; -&gt;&nbsp; &nbsp; 10 -&gt; 5 -&gt; 5 -&gt; 8</div>	<b>Solution 1:</b>&nbsp;Iteratively 3 pointers&nbsp;<div>&nbsp;- Use three pointers</div><div>&nbsp; &nbsp; &nbsp; Pointer 1: The last node &gt; partition</div><div>&nbsp; &nbsp; &nbsp; Pointer 2: The last node &lt;= partition</div><div>&nbsp; &nbsp; &nbsp; Pointer 3: Runner which checks each node &gt; or &lt;= partition</div><div>- If node &lt;= partition set P2.next = node and P2 = P2.next</div><div>- If node &gt; partition set P1.next = node and P1 = P1.next</div><div>- Keep track of <b>first node</b> &gt; partition</div><div>- Set P2.next = <b>first node</b></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(1)</div><div><br></div><div><b>Other Solutions:</b></div><div>Use two pointers and either put elements at the head or tail of node. This has less pointers but will loose order.</div>	
Sum Lists: You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linkedin list.<div>E.g. 7-&gt;1-&gt;6 + 5-&gt;9-&gt;]2 ==&gt; 2-&gt;1-&gt;9</div>	<b>Solution&nbsp;1:</b><div>- Create a new linked list and head for that list</div><div>- Create a while loop that is dependent on l1, l2 and rem</div><div>- Add l1 and l2 if they are not None</div><div>- Used rem, val = divmod(val1 + val2 + rem, 10)</div><div>- Add val to next node&nbsp;</div><div>- Move l1 and l2 if next is not None</div><div>- Return head.next</div><div><b>Time/Space:</b></div><div>Time O(n + m)</div><div>Space O(n + m)</div>	
Palindrome: Implement a function to check if a linked list is a palindrome	"<b>Solution 1: My Solution</b><div>- Have a normal and runner pointer. Increment each until runner hits end.</div><div>- Save the end point</div><div>- Reverse list until hitting normal point</div><div>- Start on both ends and inc until one.next == other or one == other</div><div>&nbsp; &nbsp; &nbsp; &nbsp;if c1 != c2 return false</div><div><b>Space/Time:</b></div><div>Time O(n)</div><div>Space(1)</div><div><b>Questions:</b></div><div>The problem with this solution is that multiple threads could not be using this data</div><div><br></div><div><b>Solution 2: Recursion</b></div><div>- Recurse until the end</div><div>- Have a self.headnode</div><div>- Check that headnode == endnode</div><div>- Increment headnode by one<img src=""Screen Shot 2021-09-01 at 7.19.00 AM.png""></div><div><br></div><div><b>Other Solutions:</b></div><div>Use a stack and pop off once you get to the middle <b>Space:</b>&nbsp;O(n)</div><div>Create a clone, reverse the list and compare <b>Space: </b>O(n)</div><div><br></div>"	
Intersection: Given two linked lists, determine if the two lists intersect. Return the intersecting node. Note that the intersection is defined based on reference not value.	<b>Solution 1:</b><div>- Walk through and count the length of both lists</div><div>&nbsp; &nbsp; &nbsp; if the last nodes != return false</div><div>- Which ever list is larger, walk forward until they are same length</div><div>- Walk both forward until n1 == n1</div><div>&nbsp; &nbsp; &nbsp; return node</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(1)</div>	
Loop Detectioin: Given a linked list which might contain a loop, implement an algorithm that returns the node at the beginning of the loop	<b>Solution 1</b>: <b>Tortoise and Hare</b><div>- Start nodes one move +1 (node1 : tortoise) and other moves +2 (node2 : hare)</div><div>- Go until node2 is null or when intersect node1</div><div>- If they intersect, start a new node at the head (node3) and inc by 1 with node1 until they intersect&nbsp;</div><div>&nbsp; &nbsp; &nbsp; Return intersect node</div>	
Three in One: Describe how you could use a single array to implement three stacks.	<b>Solution 1:</b>&nbsp;<b>Fixed size for each</b><div>- Navigate the stack using the following translation Stack1 = i // 3, Stack2 = i // 3 + 1, Stack3 = i//3 + 2</div><div>- Keep track of the top of stacks</div><div>- If one of the stacks exceeds add 3 more index or unless we have a max capacity</div><div><br></div><div><b>Solution 2: Making the Stack Flexible</b></div><div>- Stacks can wrap. We have a starting and end point. If end point hits starting point shift all elements forward</div><div><br></div><div><b>Questions:</b></div><div>- Do we have a max stack size? Total stack size?</div><div>- What type of operation do we want to have?</div>	
Stack Min: how would you design a stack which can do push, pop and min. All should operate in O(1) time.	<b>Solution 1:</b><div>Keep track of what the min is at that moment for each layer of the stack</div><div>E.g. [val, min] =&gt; [[3,3], [4,3], [2,2], [3,2]]</div>	
Queue via Stacks: Implement a MyQueue class which implements a queue using two stacks	<b>Solution 1:</b>&nbsp;<div>- Have two stacks</div><div>- One is used for push and other for pop</div><div>- When pop stack is empty, place all push stack on pop stack.</div><div><br></div><div><b>Space/Time:</b></div><div>Time: O(n) worse or O(1) best</div><div>Space: O(n)</div><div><br></div>	
Stack Of Plates: Create a stack class which maintains the height of the stacks on a certain threshold (max height). Should have pop(), push(), popAt().&nbsp;	<b>Solution 1:</b><div>- Create a max_height variable which is init at the beginning</div><div>- Keeps a list of lists [ [], [], [] ]</div><div><br></div><div>push()</div><div>- Check isPoped queue and push to front of queue stack, return, else</div><div>- Checks current list size</div><div>&nbsp; &nbsp; &nbsp; if &gt; max, create a new list</div><div>&nbsp; &nbsp; &nbsp; if &lt; max, add to current list</div><div><br></div><div>pop()</div><div>- Pop current stack</div><div>&nbsp; &nbsp; &nbsp; if stack.isEmpty, remove stack and shift down</div><div><br></div><div>popAt()</div><div>- Pop at stack specified and add index to isPoped queue</div><div>- If stack empty return null</div><div><br></div>	
Sort Stack: Write a program to sort a stack such that the smallest items are on the top. You can use an additional temp stack, but you may not copy the elements into any other data strucuture. Has following push, pop, peek, and isEmpty.	<b>Solution 1: For Stack class that keeps them sorted</b><div>We have two stacks.&nbsp;</div><div>Stack 1: Holds the values</div><div>Stack 2: Holds the temp values and used for push()</div><div><br></div><div>pop(), peek() and isEmpty() would behave the same and opperate on Stack 1.<br></div><div><br></div><div>push()</div><div>- Pop off elements and put them on Stack 2</div><div>- Do this until: prev.popped.val &lt; push.val &lt; curr.popped.val</div><div>- Add add curr.popped and push.val to Stack 1</div><div>- Add all other values from Stack 2 back onto Stack 1</div><div><br></div><div><b>Space/Time:</b></div><div>Space O(n)</div><div>Time pop() = O(1), peek = O(1), isEmpty = O(1), push = O(n)</div><div><br></div><div><b>Solution 2: Given a stack, sort the stack</b></div><div>Use selection sort</div><div>Stack 1: Sorted&nbsp;</div><div>Stack 2: Non-Sorted&nbsp;&nbsp;</div><div><br></div><div>Pull top value from Stack 2</div><div>&nbsp; &nbsp;if Sorted.top.val &gt; Unsorted.top.val</div><div>&nbsp; &nbsp; &nbsp; Push Unsorted.top onto Stack 1</div><div>&nbsp; &nbsp;else</div><div>&nbsp; &nbsp; &nbsp; Push top val from Stack 1 onto Stack 2</div><div>Repeat above process until Stack2.isEmpty()</div>	
An animal shelter, which holds only dogs and cats. Must adopt oldest and can have choice of dog, cat or either. Create data structure that has the following operations: enqueue(), dequeueOldest, dequeueDog and dequeueCat.	<b>Solution 1:</b><div>Create two diffferent stacks</div><div><br></div><div>Stack 1: [[dogName, timestamp], ...]</div><div>Stack 2: [[catName, timestamp], ...]</div><div><br></div><div>enqueue()</div><div>Add to either Stack 1 or 2 depending on type</div><div><br></div><div>dequeueAny()</div><div>Compare both Stacks and pop one with oldest time stamp</div><div><br></div><div>dequeueDog()</div><div>Pop Stack 1 queue</div><div><br></div><div>dequeueCat()</div><div>Pop Stack 2 queue</div><div><br></div>	
Route Between Nodes: Given a directed graph and two nodes (S and E), design an algorithm to find out whether there is a route from S to E.	"<b>Solution 1: DFS</b><div>Recursive<br><div><img src=""Screen Shot 2021-09-09 at 6.31.39 AM.png""></div><div><br></div><div>Iterative</div><div><img src=""Screen Shot 2021-09-09 at 7.07.07 AM.png""><br></div><div><br></div><div><b>Time/Space:</b></div><div>Time O(E + V)</div><div>Space O(V) (or longest path)</div><div><br><div><b>Solution 2: BFS</b></div><div><b><br></b></div><div><img src=""Screen Shot 2021-09-09 at 7.04.06 AM.png""><b><br></b></div><div><div><b><br></b></div><div><b>Time/Space:</b></div><div>Graph - Time O(E + V)</div><div>Tree - Time O(V)</div><div><br></div><div>Graph - Space O(V)</div></div><div>Tree - Space O(V)<br></div><div><b><br></b></div><div><b>Questions:</b>&nbsp;</div><div>- Easy?</div><div>&nbsp; &nbsp; &nbsp; DFS is much easier to implement</div><div>- Are the nodes close together?</div><div>&nbsp; &nbsp; &nbsp; Yes, BFS</div><div>- How wide is the tree?</div><div>&nbsp; &nbsp; &nbsp; Yes, DFS because BFS might take too much memory</div><div>- Would we eventually want to run on multiple machines?</div><div>&nbsp; &nbsp; &nbsp; Yes, DFS might be better because BFS would need to share data structures</div><div>- Are we wanting to find the shortest path?</div><div>&nbsp; &nbsp; &nbsp; Yes, BFS will find shortest path</div><div><b><br></b></div></div></div>"	
Minimal Tree: Given a sorted array with unique integer elements, write an algorithm to create a binary searcch tree with minimal height.	"<b>Solution 1:&nbsp;</b><div>Use Binary Search</div><div>- Create a function returns the middle node of a high and low range and apppends the left and right side to the left and right pointers of the node</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(log n) - Based on recursion stack</div><div><br></div><div><b>Question:</b></div><div>Is the data structure returned appart of the space?</div><div><br></div><div><br></div><div><img src=""Screen Shot 2021-09-09 at 7.33.09 PM.png""><br><div><div><b><br></b></div></div></div>"	
List of Depths: Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth.	"<b>Solution 1: Recursion</b><div>Create a recursive function that takes in node and depth.</div><div>It would start with createArray(head, 0)</div><div>If len(array)&gt;depth, append new array</div><div><br></div><div><b>Time/Space</b></div><div>Time O(n)</div><div>Space O(n) or O(log(n)) if balanced and not counting returned structure</div><div><br></div><div><b>Solution 2: Use BFS</b></div><div>Essentially every time you repeat the loop you append all the elements of the ""queue"" you have created</div><div><br></div><div><b>Time/Space</b></div><div>Time O(n)</div><div>Space O(1)</div><div><br></div><div><img src=""Screen Shot 2021-09-09 at 8.15.06 PM.png""><br><div><div><b><br></b></div></div></div>"	
Check Balanced: Implement a function to check if a binary tree is balanced. For the purposes of this questioin, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.&nbsp;	"<div><b>Solution 1: Bottom Up Recursion</b></div><div>Return the max height each step of the way.</div><div>If at any point difference &gt; 1 return false</div><div>Always check that left and right aren't false before returning</div><div>Convert to bool since height will never be zero which is the only way ints will be false</div><div><br></div><div><b>Space/Time:</b></div><div>Time O(n)</div><div>Space O(n) or O(log n) if balanced</div><div><br></div><div><b>Comments:</b></div><div>Could optimize code by left ? false : true right after balance check</div><div><br></div><div><br></div><img src=""Screen Shot 2021-09-09 at 8.50.59 PM.png""><br>"	
Validate BST: Implement a function to check if a binary tree is a binary search tree.	"<b>Solution 1: In-Order Trans (No duplicates)</b><div>Create an array by transversing array in order</div><div>Check that array is sorted</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n)</div><div><br></div><div><br></div><div><b>Solution 2: Down Up Recursion</b></div><div>Pass the min and max element up to the node above</div><div>max(left.vals) &lt;= cur.val &lt; min(right.vals)</div><div><br></div><div>Passing up</div><div>- left.vals will have the min element</div><div>- right.vals will have the max element</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n) or O(h) =&gt; O(log n) for balanced</div><div><div><b><br></b></div></div><div><img src=""Screen Shot 2021-09-10 at 7.45.26 AM.png""></div><div><b><br></b></div><div><b><br></b></div><div><b>Solution 3: Top Down Recursion</b></div><div>Pass in the lowest and highest value that the node below has to abide by.</div><div><br></div><div>Left Node</div><div>&nbsp; &nbsp;- Lowest bound should be current lowest</div><div>&nbsp; &nbsp;- Highest&nbsp;bound should be node.val</div><div>Right Node</div><div>&nbsp; &nbsp;- Lowest&nbsp;bound should be node.val</div><div>&nbsp; &nbsp;- Highest bound should be current highest</div><div><br></div><div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(n) or O(h) =&gt; O(log n) for balanced</div></div><div><b><br></b></div><div><img src=""Screen Shot 2021-09-10 at 8.14.19 AM.png""><b><br></b></div><div><b><br></b></div>"	
"Successor: Write an algorithm to find the ""next"" node of a given node in a binary search tree. You may assume there is a link to the parent."	<b>Solution 1:</b><div>For each node check the following:</div><div>- Right Node</div><div>&nbsp; &nbsp;1. Go leftmost node</div><div>&nbsp; &nbsp;2. Return node</div><div>- Right parent</div><div>&nbsp; &nbsp;1. Return node</div><div>- Left parent</div><div>&nbsp; &nbsp;1. Keep going until right parent</div><div>&nbsp; &nbsp;2. If never find return Null</div><div>&nbsp; &nbsp;3. When right, return node</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(1)</div>	
Build Order: You are given a list of projects and a list of dependencies. All of a project's dependencies must be built befoore the project is. Find a build order that will allow the projects to be built. If there is no valid build order, return an error.	"<b>Solution 1: Create graph, DFS each node</b><div>- Create graph of all dependencies&nbsp;</div><div>- Nodes can be either 1. New 2. Visiting 3. Visited</div><div>- Loop through all non-visited nodes and run a modified DFS</div><div>- return path in reverse</div><div><br></div><div>Modified DFS</div><div>- Mark node as visiting</div><div>- Loop through nodes pointed to</div><div>&nbsp; &nbsp; &nbsp; If visiting ==&gt; loop</div><div>&nbsp; &nbsp; &nbsp; If not visited ==&gt; run Modified DFS on it</div><div>- Mark node as visited</div><div>- Append node to path</div><div><br></div><div><b>Space/Time:</b></div><div>Space O(V + E)</div><div>Time O(V + E)</div><div><br></div><div><img src=""Screen Shot 2021-09-12 at 1.46.43 PM.png""><br></div><div><br></div><div><b>Solution 2: Use a array and queue</b></div><div>- Create list of lists which index matches with class number (or dict in this case)</div><div>- Create another array which increases each time there is a prereq for class</div><div>&nbsp; &nbsp; &nbsp; Walk through array and add to queue values with no prereqs</div><div>- Create while queue == True</div><div>- Pop (add to path) and add nodes pointed to that don't have prereqs</div><div>- If length path != course number ==&gt; there's a loop</div><div><br></div><div><div><b>Space/Time:</b></div><div>Space O(V + E)</div><div>Time O(V + E)</div></div><div><br></div><div><img src=""Screen Shot 2021-09-12 at 1.44.24 PM.png"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br></div><div><br></div><div><br></div>"	
Declare a List of Lists in Python	list_of_lists = [[] for _ in range(numOfLists)]<br>	
First Common Ancestor: Design an algorithm and write code to find the first common anscestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure	"<b>Solution 1: Bottom up recursion (my way)</b><div><div>Checks left and right by calling function again</div><div><br></div><div>Returns<br></div><div>0 if node == None</div><div>1 if current node is == p,q</div><div>-1 if left and right == 1 or one of them and current node</div><div>&nbsp; &nbsp; &nbsp; Set self.ret_n = node</div><div><div><br></div><div><b>Edge Cases:</b></div><div>The node is the anscestor</div><div>Give null input</div><div>P == Q?</div><div><br></div><div><b>Questions:</b></div><div>Will there always be an anscestor? E.g. P and q != None</div><div>Can the two nodes be the same?&nbsp;</div><div><b><br></b></div><div><b>Time/Space:</b></div></div></div><div>Time O(n)</div><div>Space O(n) or log(n)/height if balanced</div><div><img src=""Screen Shot 2021-09-12 at 6.01.40 PM.png""><br></div><div><b><br></b></div><div><b>Solution 2: Passes up either nodes or parent</b></div><div>Calls the function again on left and right</div><div>If (left and right) or (node in [p, q])</div><div>&nbsp; &nbsp;return node</div><div>return left or right</div><div><br></div><div><img src=""Screen Shot 2021-09-12 at 6.05.21 PM.png""><br></div>"	
BST Sequences: A binary search tree was created by transversing through an array from left to right and inserting each element. Given a binary search tree with distinct elements print all possible arrays that could have let to this tree.	<b>Solution 1:</b>&nbsp;<div>Recursive Function<br><div>- Pass in one option for order and array of children</div><div>- Add all children to pass function and add children's children to array</div><div><br></div><div>E.g.</div><div><br></div><div>&nbsp; &nbsp; 2</div><div>&nbsp; /&nbsp; &nbsp; \&nbsp; &nbsp; &nbsp;=&gt;&nbsp; &nbsp; &nbsp;[2] [1,3]&nbsp; &nbsp; &nbsp;=&gt;&nbsp; &nbsp; &nbsp;[2,1] [3], [2,3][1]&nbsp; &nbsp; &nbsp;=&gt;&nbsp; &nbsp; &nbsp;[2,1,3],[2,3,1]</div><div>1&nbsp; &nbsp; &nbsp; 3</div><div><br></div><div><b>Time/Space:</b></div><div>??????</div></div><div><br></div><div>https://leetcode.com/problems/unique-binary-search-trees-ii/<br></div><div>https://leetcode.com/problems/unique-binary-search-trees/<br></div><div>https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/<br></div>	
Check Subtree: T1 and T2 are two very large binary trees, with T1 much bigger thatn T2. Create an Algorithm to determine if T2 is a subtree of T1.	<div><b>Solution 1: Pre Order&nbsp;</b></div><div>Simply create an array of post order for both arrays (would need to include Nones)</div><div>Check to see if smaller array is contained in larger array</div><div><br></div><div><b>Time/Space:</b></div><div>Space O(n1 + n2)</div><div>Time O(n1*n2)</div><b><div><b><br></b></div><div><b><br></b></div>Solution 2:</b><div>Create two functions:</div><div><br></div><div>Function 1</div><div>Check all elements of T1 and compare to head of T2.</div><div>&nbsp; &nbsp;If T1.node = T2.head, put both nodes in Function 2</div><div><br></div><div>Function 2</div><div>Check all nodes between two trees equal each other</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n1*n2) if all nodes T1 ~= T2</div><div>&nbsp; &nbsp; &nbsp; You could also make the arguement of O(n1 + n1/p*n2) with p being equal to the range of random numbers chosen&nbsp;</div><div>Space O(1)</div>	
Random Node: You are implementing a binary searcch tree class from scratch which, in addition to insert, find and delete has a method getRandomNode() which returns a random node from the tree. All nodes should be equally likely to be cchosen. Design and implement an algorithm fro getRandomNode, and explain how you would implement the rest of the methods.	<b>Solution 1:</b><div>Each node holds how many children nodes it has.</div><div>It calculates whether it should go right or left based on that number</div><div>Calculate one random number and then&nbsp;</div><div>&nbsp; &nbsp;Right: Subtract the left and current value and divide by right</div><div>&nbsp; &nbsp;Left: divide by left</div><div><br></div><div>E.g. Below: 1/5 current node, 1/5 right node and 3/5 left node<br></div><div><br></div><div>RandNum &lt; 3/5 ==&gt; left</div><div>RandNum &gt; 4/5 ==&gt; right</div><div>else ==&gt; current</div><div><br></div><div>if go left: 1/3 left, 1/3 current, 1/3 right</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; (4)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; &nbsp; \</div><div>&nbsp; &nbsp; (2)&nbsp; &nbsp; (0)</div><div>&nbsp; &nbsp; /&nbsp; \</div><div>(0)&nbsp; &nbsp;(0)</div><div><br></div><div><b>Time/Space</b>:</div><div>Time O(n)</div><div>Space O(n)</div>	
Paths with Sum: You are given a binary tree in which each node contains an integer value. Design an algorith to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf but it must go downwards.	<b>Solution 1:</b><div><b><br></b></div><div><b>Question:</b></div><div>There can be negative numbers?</div><div>Can one value equal sum?</div><div><br></div><div><b>Time/Space:</b></div><div><b><br></b></div>	
Path with Sum: You are given a binary tree in which each node contains an interger value. Design an algorithm to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf but it must go downwards.&nbsp;	<b>Solution 1:</b><div>Create a running runningSum and increment each pass with node.val</div><div>Check if runningSum - targetSum is in hash.&nbsp;</div><div>&nbsp; &nbsp; &nbsp; if yes, increment found by number of val</div><div>Add runningSum to hash map&nbsp;</div><div>pass left and right</div><div>Decrement after passing so that above doesn't use it.</div><div><br></div><div><b>Time/Space:</b></div><div>Time O(n)</div><div>Space O(log n) if balanced, else O(n) due to hash</div>	
Insertion: You are give two 32 bit numbers, N and M and two bit positions, i and j. Write a method to insert M in to N such that M starts at bit j and ends at bit i.<div>E.g. N = 10000000000, M = 10011, i = 2, j = 6&nbsp;</div><div>==&gt; 10001001100</div>	"<div><b>Solution:</b></div><div>1. Clear bits i through j in N</div><div>2. Shift M over</div><div>3. Merge M into N</div><div><br></div><div><img src=""Screen Shot 2021-09-27 at 7.29.03 PM.png""><b><br></b></div><div><b><br></b></div><div><b>Space/Time:</b></div><div>Time O(1)&nbsp;</div><div>Space O(1)</div><div><b><br></b></div>"	
Binary to String: Given a real number between 0 and 1 that is passed in as a double, print the binary representation. If the knumber cannot be represented accurately in binary with at most 32 characters, print 'ERROR'	"<b>Solution 1:</b><div>Double the value,</div><div>If &gt; 1</div><div>&nbsp; &nbsp;Append 1</div><div>&nbsp; &nbsp;num--</div><div>if &lt; 1</div><div>&nbsp; &nbsp;Append 0</div><div><br></div><div><img src=""Screen Shot 2021-10-13 at 5.34.51 PM.png""><br></div>"	
You have an integer and you can flip exactly one bit from 0 to a 1. Write code to find the length of the longest squeence of 1s you could create.<div><br></div><div>1775 (11011101111) ==&gt; 8</div>	"<b>Solution 1:</b><div>Walk through integer,</div><div>Keep current length and prev length</div><div><br></div><div>If bit == 1</div><div>&nbsp; &nbsp;current_length += 1</div><div>if bit == 0 and next_bit == 0:</div><div>&nbsp; &nbsp;current_length = 0</div><div>&nbsp; &nbsp;prev_length = 0</div><div>if bit == 0 and next_bit == 1:</div><div>&nbsp; &nbsp;prev_length = current_length + 1<br></div><div>&nbsp; &nbsp;current_length = 0</div><div><br></div><div>max_length = max(prev_length + current_length, max_length)</div><div><br></div><div>Below shows how to navigate the binary_val</div><div><img src=""Screen Shot 2021-10-13 at 6.16.25 PM.png""><br></div><div><br></div><div><b>Space/Time:</b></div><div>Space O(1)</div><div>Time O(b)</div>"	
Explain what the following code does: ((n &amp; (n-1)) == 0)	Returns true if there is only a single bit is set for n	
When asked a object-oriented design question, what should you inquire?	You should ask how they are going to use it. Depending on question, you may go through the six W's.	
How to check if a bit is all ones? (e.g. 0b0001111	if not (binary_val + 1) &amp; binary_val ===&gt; 0<br>	
How do you approach OOD questions?	1. Handle Ambiguity<div>&nbsp; &nbsp; &nbsp; - Ask who is going to use it (6 Ws)</div><div>&nbsp; &nbsp; &nbsp; - Feel out how big of scale</div><div>2. Define Core objects</div><div>&nbsp; &nbsp; &nbsp; - E.g. A restaurant =&gt; Table, Guest, Party, Order, Meal, Employee, Server, Host</div><div>3. Define Relationships between objects</div><div>&nbsp; &nbsp; &nbsp; - E.g. Party has array of guests, Server/Host inherit from employee, Each Table has one Party</div><div>&nbsp; &nbsp; &nbsp; - Talk through these different assumptions and make sure on same page</div><div>4. Investigate Actions</div><div>&nbsp; &nbsp; &nbsp; - Key actions that the objects will take</div><div>&nbsp; &nbsp; &nbsp; - How they relate to each other</div>	